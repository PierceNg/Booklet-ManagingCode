!! Publishing your first Pharo project

In this chapter we explain how you can publish your project on github using Iceberg.
We do not explain basic concepts like commit, push/pull, merging, or cloning.

A strong precondition before reading this chapter is that you must be able to publish from the command line 
to the git hosting service that you want to use. If you cannot do not expect Iceberg to fix it magically for you. You can have a look in Chapter *@cha:tips* the section explaining how to generate SSH keys. 
We thank Peter Uhnak for his first blog on publishing Pharo code on Github.
Let us get started.

!!! For the impatient

If you do not want to read everything, here is the executive summary.

- Create a project on github or any git-based platform.
- Configure Iceberg to use custom ssh keys.
- Add a project in Iceberg.
-- Optionally, in the cloned repository, create a directory named ==src== on your file system. This is a good convention.
- In Iceberg, open your project and add your packages (It is always good to add a baseline).
- Commit your project.
- Push your change to your remote repository.

You are done. Now we can explain calmly.


!!! Architecture

As git is a distributed versioning system, you need a local clone of the repository (usually on your machine). This is to this local repository that your changes will be commited to before being pushed to remote repositories.
In general you commit to your local clone, and from there you push to remote repositories like  github or gitlab, or that of your company.
Iceberg will do all the operations and more for you.


!!! Iceberg setup: Tell Pharo to use your keys
To be able to commit to your git project, you will need to set up valid credentials in your system.
In case you use SSH (the default way), you will need to make sure those keys are available to your github account and also that the shell adds them for smoother communication with the server. 
See the Chapter *@cha:tips* Tips and Tricks for some help with setting up your ssh keys. 


Go to settings browser, search for "Use custom SSH keys" and enter your data there as shown in Figure *@UseCustom*).

+Use Custom SSH keys settings.>file://figures/useCustom.png|width=75|label=UseCustom+

Alternatively, you can execute the following expressions in your image playground or add them to your Pharo system preference file (See Menu System item startup):

[[[
IceCredentialsProvider useCustomSsh: true.
IceCredentialsProvider sshCredentials
  publicKey: 'path\to\ssh\id_rsa.pub';
  privateKey: 'path\to\ssh\id_rsa'
]]]

@@note ""Pro Tip:"" this can be used too in case you have a non-default key file. You just need to replace ==id_rsa== with your file name.


!!! Create a new project on Github
While you can save locally first and then later create a remote repository we first create a new project on Github. Figure *@onGitHub* shows the creation of a project on Github. 
The order does not really matter. What is different is that you should use different options when add a repository to Iceberg as we will show later.

+Create a new project.>file://figures/onGitHub.png|width=75|label=onGitHub+


!!! Opening Iceberg

Figure *@freshiceberg* shows the top level Iceberg pane. 
It shows that for now you do not have define or loaded any project. It shows the Pharo project and indicates that it could not find the local repository of Pharo with 'Local repository missing'. 

First you do not have to worry about the  Pharo or repository if you do not want to contribute to Pharo. 
So just go ahead. Now if you want to understand what is happening here is the explanation. 
The Pharo system does not have any idea where it should look for the git repository corresponding to the source of the classes it contains. Indeed, the image you are executing may have being build somewhere, patched or not many times. Now Pharo can fully execute without having a local repository. You can browse system classes and methods because Pharo has its own internal source management. This warning just indicates that if you want to version Pharo system code using git then you should indicate to the system where the clone is located on your local machine. 
So if you do not plan to modify and version Pharo code, you do not have to worry. 

+Opening Iceberg on fresh image indicates that if you want to version modifications to Pharo itself you will have to tell Iceberg where the Pharo clone is located.>file://figures/S1-OpeningIceberg.png|width=75|label=freshiceberg+


!!! Add a new project to Iceberg

The first step is then to add a project to Iceberg:
- Press the '+' button to the right of the Iceberg main window.
- Select the source of your project. In our example, since you did not clone your project yet, choose the Github option.

Figure *@Cloning* instructs Iceberg to clone the repository we just created on Github. 
We specify the owner, project, and physical location where the local clone and git working copy will be on your disk.

+Cloning a project hosted on Github.>file://figures/S5-CloneFromGithub.png|width=75|label=Cloning+

Iceberg has now added your project to its list of managed projects and cloned an empty repository to your disk. You will see the status of your project, as in Figure *@FirstTimeCloned*. Here is a breakdown of what you are seeing:
- MyCoolProjectWithPharo has a star and is green. This usually means that you have changes which haven't been committed yet, but may also happen in unrelated edge cases like this one. Don't worry about this for now.
- The Status of the project is 'No Project Found' and this is more important. This is normal since the project is empty. Iceberg cannot find its metadata. We will fix this soon.

+Just after cloning an empty project.>file://figures/S6-ProjectNotFound.png|width=75|label=FirstTimeCloned+


Later on, when you will have commited changes to your project and you want to load it in another image, 
when you will clone again, you will see that Iceberg will just report that the project is not loaded as shown in Figure *@ProjectWithCommits*.

+Adding a project with some contents shows  that the project is not loaded - not that it is not found.>file://figures/S7-ProjectNotLoaded.png|width=75|label=ProjectWithCommits+

!!! Repair to the rescue

Iceberg is a smart tool that tries to help you fix the problems you may encounter while working with git.
As a general principle, each time you get a status with red text (such as "No Project Found" or "Detached Working Copy"), you should ask Iceberg to fix it using the ""Repair"" command.

Iceberg cannot solve all situations automatically, but it will propose and explain possible repair actions.
The actions are ranked from most to least probable.
Each action will explain the situation and the consequence of the proposed action.
It is always a good idea to read them. 
If you do not like a fool you should not lose any code with Iceberg (Note that Pharo still contain a copy of the code).

+Create project metadata action and explanation.>file://figures/S8-RepairFirst.png|width=75|label=RepairFirst+

!!! Create project metadata
Iceberg reported that it could not find the project because some meta data were missing such as the format of the code encodings and the example location inside the repository. When we activate the repair command we get the Figure *@RepairFirst*.  It shows the "Create project metadata" action and its explanation.


When you choose to create the project metadata, Iceberg shows you the filesystem of your project as well as the repository format as shown in Figure *@Tonel*. Tonel is the preferred format for Pharo projects.
It has been designed to be Windows and file system friendly. Change it only if you know what you're doing! 

+Showing where the metadata will be saved and the format encodings.>file://figures/S9-MetaData1.png|width=65|label=Tonel+

Before accepting the changes, it is a good idea to add a source (==src==) folder to your repository. 
Do that by pressing the + icon. You will be prompted to specify the folder for code as shown in Figure *@metadatasrc*. Iceberg will show you the exact strcutures of your project as shown in Figure *@metadatasrc2*.

+Adding a src repository for code storage.>file://figures/S9-MetaData2.png|width=50|label=metadatasrc+

+Resulting situation with a src folder.>file://figures/S9-MetaData3.png|width=50|label=metadatasrc2+

After accepting the project details, Iceberg shows you the files that you will be committing as shown in Figure *@PublishingMetaData*

+Details of metadata commit.>file://figures/S9-MetaData4.png|width=75|label=PublishingMetaData+

Once you have committed the metadata, Iceberg shows you that your project has been repaired but is not loaded as shown in Figure *@ProjectWithCommits*. This is normal since we haven't added any packages to our project yet. You can optionally push your changes to your remote repository.

Your local repository is ready, so let's do that now.

!!! Adding and commiting your package
Once your project contains Iceberg metadata, Iceberg will be able to manage it easily. 
Double click on your project and add a package by pressing the + (Add Package) iconic button as shown by Figure *@WithAPackage*.

+Adding a package to your project.>file://figures/S10-AddingAPackage.png|width=75|label=WithAPackage+

Again, Iceberg shows that your package contains changes that are not committed using the green color and the * in front of the package name as showing in Figure *@Dirty*.

+Iceberg indicates that your package has unsaved changes -- indeed you just added your package.>file://figures/Dirty.png|width=50|label=Dirty+

+When you commit changes, Iceberg shows you the code about to commit and you can select .>file://figures/S11-DirtyCommit.png|width=50|label=DirtyCleaned+

+Once commited Iceberg reflects that your project is in sync with the code in your local repository.>file://figures/S11-DirtyBecomeClean.png|width=50|label=S11-DirtyBecomeClean+

!!!! Commit the changes
Commit the changes to your local repository using the Commit button as shown in Figure *@DirtyCleaned*.
Iceberg let you cherry pick the changes you want to commit. Here this is not needed but this is an important features. Iceberg will reflect this change by removing the * and the changing the color and show that the code in the image is in sync with your local repository as shown by Figure *@S11-DirtyBecomeClean*.
You can commit several times if needed.


!!!! Publish your changes to your remote
Now you are nearly done. Publish your changes from your local directory to your remote repository using the Push button. 

When you push your changes, Iceberg will show you all the commits awaiting publication and will push them to your remote repository as shown in Figure *@Push*. The figure shows the commits we are about to make to add a baseline, which will allow you to easily load your project in other images.

+Publishing your committed changes.>file://figures/push.png|width=75|label=Push+

Now you are basically done. 


!!! Conclusion

You know now the essential aspects of managing your code with github.
Iceberg has been designed to guide you so listen to it. 
Now you are ready to use services offered around GitHub to improve your  quality.



!! Configure nicely a project

In this chapter ...



!!! What if I do not have created a remote repository

At the beginning of this chapter we started by create a remote repository on Github. 
Then we asked Iceberg to add a project by cloniong from Github. 
Now you may ask yourself what is the process to publish first your project locally without a pre-existing repository. This is actually simple.

!!!! Create a new repository. 
When you add a new repository use the 'New repository' option as shown in *@NewRepo*.
 
+Creating a local repository without pre-existing remote repository .>file://figures/S12-NewRepository.png|width=75|label=NewRepo+

!!!! Add a remote.
If you want to then commit to a remote repository, you will have to add a repository using the repository browser you can access using the associated menu item or the icon. Figure *@OpeningRepositoryBrowser* shows the repository browser on our project.

+Opening the repository browser .>file://figures/S13-OpeningRepository.png|width=75|label=OpeningRepositoryBrowser+

Using the 'Add remote' iconic button add a remote by just providing information that you can find in your Github project. Figure *@OpeningRepositoryBrowser* shows it for the sample project.

+Adding a remote.>file://figures/S14-AddingRemote.png|width=75|label=OpeningRepositoryBrowser+

!!!! Push to the remote.

Now you can push your changes and versions to the remote repository using the Push iconic button. 
Once you have pushed you see that you have one remote as shown in Figure *@PushedFromReport*.

+Pushing to the remote.>file://figures/S15-PushedFromReport.png|width=75|label=PushedFromReport+

!!! Defining a BaselineOf

A BaselineOf is a description of a project's architecture.
You will express the dependencies between your packages and other projects so that all the dependent projects are loaded without the user having to understand and bother about them.
A baseline is expressed as a subclass of ==BaselineOf== and packaged in a package named =='BaselineOfXXX'== (where 'XXX' is the name of your project).

So if you have no dependencies, you can have something like this.

[[[
BaselineOf subclass: #BaselineOfMyCoolProjectWithPharo
  ...
  package: 'BaselineOfMyCoolProjectWithPharo'
]]]

[[[
BaselineOfMyCoolProjectWithPharo >> baseline: spec
  <baseline>
  spec
    for: #common
    do: [ spec package: 'BMyCoolProjectWithPharo'.
      spec group: 'default' with: #('FileDialog') ]
]]]

Once you have defined your baseline, you should add it to your project as shown in Figure *@WithBaseline*.
Now, commit it and push your changes to your remote repository.

+With a Baseline.>file://figures/WithBaseline.png|width=75|label=WithBaseline+

The online baseline documentation is available at: *https://github.com/pharo-open-documentation/pharo-wiki/blob/master/General/Baselines.md*.


!!! Loading from an existing repository

If you already have a repository, and you just want to load it into Pharo, there are two ways to go about it.
The first is as we did above. You can select a package and manually load it.

The second makes use of Metacello. 
However, this will only work if you have already created a ==BaselineOf==.
In this case, you can just do:

[[[
Metacello new
  baseline: 'MyCoolFirstProjectWithPharo';
  repository: 'github://Ducasse/MyCoolProjectWithPharo';
  load
]]]

For projects with metadata, like the one we just created, that's it. However, if you are loading a project without metadata, you must add the code subfolder to the end of the repository string i.e. 'github://Ducasse/MyCoolProjectWithPharo/src'.

!!! [Optional] Add a nice .gitignore file

Iceberg automatically manages such files.
[[[
# For Pharo 70 and up
# http://www.pharo.org
# Since Pharo 70 all the community is moving to git.

# image, changes and sources
*.changes
*.sources
*.image

# Pharo Debug log file and launcher metadata
PharoDebug.log
pharo.version
meta-inf.ston

# Since Pharo 70, all local cache files for Monticello package cache, playground, epicea... are under the pharo-local
/pharo-local

# Metacello-github cache
/github-cache
github-*.zip
]]]


!!! Going further:  Understanding the architecture

As git is a distributed versioning, you need a local clone of your repository.
In general you edit your working copy located on your disc and 
you commit to your local clone, and from there you push to remote repositories like github. We explain now the specificity of managing Pharo with git. 

Now when coding Pharo, you should understand that you are not directly editing your local working copy, you are modifying objects that represent classes and methods that are living in the Pharo environment. 
Therefore it is like you have a double working copy: Pharo itself and the git working copy. 

When you use Git command lines,  you have to understand that there is the code in the image and the code in the working code (and your local clone). So to update your image, you have to update your git working copy and load code from the working to the image. To save your code you have to save the code to files, add then to your git working copy and commit them to your clone.

Now the interesting part is that Iceberg manages all this for you transparently. 
All the synchronisation between these two working copies is done behind the scene.

Figure *@architecture* shows the architecture of the system. 

- You have your code in the Pharo image.
- Pharo is acting as a working copy (it contains the contents of the git local repository).
- Iceberg manages the publication of your code to the git working copy and the git local repository.
- Iceberg manages the publication of your code to remote repositories.
- Iceberg manages the resynchronisation of your image with the git local repository, git remote repositories and the git working copy.

+Architecture.>file://figures/architecture.png|width=75|label=architecture+


!!! Conclusion

You know now the essential aspects of managing your code with github.
Iceberg has been designed to guide you so listen to it. 
Now you are ready to use services offered around GitHub to improve your  quality.








!! Empowering your projects

Now that you can save your code on github in a breeze, you can take advantage of services
to automate actions, for example using Travis.

!!! Adding Travis integration

By adding two simple files, you can have the tests of your project automatically run after each commit with travis.
You need to enable travis in your github repository. Check your travis account. 

You should also add the two following files: ==.travis.yml== and ==.smalltalk.ston== in the top level of your 
repository. 

==.travis.yml==

[[[
language: smalltalk
sudo: false
os:
  - linux
smalltalk:
  - Pharo-7.0
]]]

==.smalltalk.ston==
[[[
SmalltalkCISpec {
  #loading : [
    SCIMetacelloLoadSpec {
      #baseline : 'MyCoolProjectWithPharo',
      #directory : src',
      #platforms : [ #pharo ]
    }
  ]
}
]]]

If you’ve done everything right, Travis will pick up the changes and will start testing and building it… and you’re done, congratulations!

!!! On windows
If you want to make sure that your code runs on windows, you should use the Appveyor service and add the appveyor.yml file.

[[[
environment:
  CYG_ROOT: C:\cygwin
  CYG_BASH: C:\cygwin\bin\bash
  CYG_CACHE: C:\cygwin\var\cache\setup
  CYG_EXE: C:\cygwin\setup-x86.exe
  CYG_MIRROR: http://cygwin.mirror.constant.com
  SCI_RUN: /cygdrive/c/smalltalkCI-master/run.sh
  matrix:
    - SMALLTALK: Pharo-6.1
    - SMALLTALK: Pharo-7.0

platform:
  - x86

install:
  - '%CYG_EXE% -dgnqNO -R "%CYG_ROOT%" -s "%CYG_MIRROR%" -l "%CYG_CACHE%" -P unzip'
  - ps: Start-FileDownload "https://github.com/hpi-swa/smalltalkCI/archive/master.zip" "C:\smalltalkCI.zip"
  - 7z x C:\smalltalkCI.zip -oC:\ -y > NULL

build: false

test_script:
  - '%CYG_BASH% -lc "cd $APPVEYOR_BUILD_FOLDER; exec 0</dev/null; $SCI_RUN"'
]]]


!!! Adding badges

With CI happily running, you can add a badge to your readme that will show the current status of your project.
Here is the badge of the Containers-Stack project where we also enabled the coveralls.io test coverage service.

[[[
# Containers-Stack
A dead stupid stack implementation, but one fully working :)

[![Build Status](https://travis-ci.com/Ducasse/Containers-Stack.svg?branch=master)]
(https://travis-ci.com/Ducasse/Containers-Stack)
[![Coverage Status](https://coveralls.io/repos/github//Ducasse/Containers-Stack/badge.svg?branch=master)]
(https://coveralls.io/github//Ducasse/Containers-Stack?branch=master)
[![License](https://img.shields.io/badge/license-MIT-blue.svg)]()
[![Pharo version](https://img.shields.io/badge/Pharo-7.0-%23aac9ff.svg)]
(https://pharo.org/download)
[![Pharo version](https://img.shields.io/badge/Pharo-8.0-%23aac9ff.svg)]
(https://pharo.org/download)

## Installation
The following script installs Containers-Stack in Pharo.

```smalltalk
Metacello new
  baseline: 'ContainersStack';
  repository: 'github://Ducasse/Containers-Stack/src';
  load.
```
]]]


To obtain the necessary link, click on the badge in your Travis project overview and select one of the options. You can insert the markdown code directly into your README.md.






